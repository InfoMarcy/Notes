#start a container in docker
docker start <container ID>
docker stop <container ID>

#Delete  a container by Name
docker rm -f unruffled_sinoussi

#Enable kubernetes on docker by going to preferences and Kebernetes

kubectl version
kubectl cluster-info
kubectl get pods
kubectl get services
kubectl delete pods <pod name>


#google course on kubernetes
1.  kubectl run nginx --image=nginx:1.10.0
2. kubectl get pods
3.  kubectl expose deployments nginx --port 80 --type LoadBalancer
4. kubectl  get services

https://medium.com/@thms.hmm/docker-for-mac-with-kubernetes-enable-k8s-dashboard-62fe036b7480

1. kubectl config use-context docker-for-desktop
2. kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml
3. kubectl get pod --namespace=kube-system | grep dashboard
4. kubectl port-forward kubernetes-dashboard-7d5dcdb6d9-xrfdv 8443:8443 --namespace=kube-system
https://localhost:8443 

#Deployment
1. kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080

#Get deployments
2. kubectl get deployments

#View our app
3. kubectl proxy

#see all those APIs hosted through the proxy endpoint,
http://localhost:8001/

query the version directly through the API using the curl command
curl http://localhost:8001/version

#The API server will automatically create an endpoint for each pod, based on the pod name, that is also accessible through the proxy.
  
#First we need to get the Pod name, and we'll store in the environment variable POD_NAME:
1. export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
2. echo Name of the Pod: $POD_NAME

#Now we can make an HTTP request to the application running in that pod:

1. curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/

2. curl http://localhost:8001/api/v1/namespaces/default/pods/kubernetes-bootcamp-5c69669756-twj99/proxy/




Troubleshooting with kubectl
#to view what containers are inside that Pod and what images are used to build those containers 
1. kubectl describe pods

#View the container logs
1. kubectl logs $POD_NAME
2. kubectl logs kubernetes-bootcamp-5c69669756-twj99

 #Executing command on the container
 We can execute commands directly on the container once the Pod is up and running
 #Let’s list the environment variables:
 1. kubectl exec $POD_NAME env
 2. kubectl exec kubernetes-bootcamp-5c69669756-twj99 env
 
 #Next let’s start a bash session in the Pod’s container:
 1.kubectl exec -ti $POD_NAME bash
 2.kubectl exec -ti kubernetes-bootcamp-5c69669756-twj99 bash
 
#We have now an open console on the container where we run our NodeJS application. 
The source code of the app is in the server.js file:

1. cat server.js

#You can check that the application is up by running a curl command:

1. curl localhost:8080

#To get out
1. exit

#NodePort - Exposes the Service on the same port of each selected Node in the cluster using NAT. 
#Makes a Service accessible from outside the cluster using <NodeIP>:<NodePort>. Superset of ClusterIP.


#You can create a Service at the same time you create a Deployment by using
--expose in kubectl.





Step 1 Create a new service
1. kubectl get pods
2. kubectl get services
#To create a new service and expose it to external traffic we’ll use the expose command with NodePort as parameter
3. kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080

#To find out what port was opened externally (by the NodePort option) 
4. kubectl describe services/kubernetes-bootcamp

#Create an environment variable called NODE_PORT that has the value of the Node port assigned:
5. export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
6. echo NODE_PORT=$NODE_PORT

#LoadBalancer Ingress:     localhost

#Now we can test that the app is exposed outside of the cluster using curl, 
#the IP of the Node and the externally exposed port:
7. curl $(minikube ip):$NODE_PORT
    curl localhost:$NODE_PORT
    
#Step 2: Using labels
1. kubectl get pods -l run=kubernetes-bootcamp
2. kubectl get services -l run=kubernetes-bootcamp

#Get the name of the Pod and store it in the POD_NAME environment variable:
3. export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
4. echo Name of the Pod: $POD_NAME


#To apply a new label we use the label command followed by the object type, object name and the new label:
5. kubectl label pod $POD_NAME app=v1
 kubectl label pod kubernetes-bootcamp-5c69669756-twj99 app=v1
 
 6. kubectl describe pods $POD_NAME
 kubectl describe pods kubernetes-bootcamp-5c69669756-twj99
 
 #We see here that the label is attached now to our Pod. And we can query now the list of pods using the new label:
 7. kubectl get pods -l app=v1


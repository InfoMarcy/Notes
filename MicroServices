Microservices 
Web service => is a service that is delivered over the web

Web => Business =>  Data

Web service => 3 Keys
1. Designed for machine-to-machine(or application-to-application ) interaction 
2. Should be interoperable - not platform independent
3. should allow communication over a network

                            Request    => input
Application =>                                       => Web Service
                           Response => output

JSON => Javascript Object Notation

Every Web service offers a Service Definition
1. Request/Response format
2. Request Structure
3. Response Structure
4. ENDPOINT => defines what url the service is exposing (how can these service consumer call the service which is expose by the service provider )

Transport => defines how a service is call over internet(http) or over a MQ

Message Exchange format => is the format of the request and the response example json
Service Provider => is the one that is hosting the web service 
Service Consumer => is the application that is consuming the web service

Rest Web services
Rest => Representational State Transfer 
REQUEST METHODS => HTTP Methods (GET, POST, PUT, DELETE, FETCH)
RESPONSE => HTTP STATUS CODES (200, 404,...)

RESOURCE => is anything that you want to expose to the outside world through your application.

Transport on Rest is always HTTP. REST is completely build over http. Rest is an architectural Style.

Swagger => 

Microservices 
1. Configuration management 
2. Dynamic load balancing 
3. Visibility 
4. good to have fault tolerance in your MicroServices


Spring cloud
Configuration management => Spring cloud Config Server => provides an approach  where you can store all  the configuration for all the different environments of all the MicroServices in a git repository. So you can store all the configuration for different environments of different MicroServices in just one place in a centralized location  and spring cloud config server  can be used to expose that configuration to all the MicroServices.
This helps us to keep the configuration in one place and that makes it very easy to maintain the configuration for all the MicroServices.

Dynamic Scale Up And Down 
1. Naming Server Eureka => it would be used to help us distribute the load balance between all the instances (multiple instances of the same service) that we have.
We would want to be able to dynamically check what are the available instances of the service that we have and make sure that the load  is distributed among all of them.

One Solution is using the Naming  Server Which is  Eureka  So all the instances of all MicroServices  would register with the naming server.

So the naming server has two important features.
1. Service registration so all MicroServices services can register  with the MicroService
2. Service Recovery in this the service parent  can ask the Naming Server give all the current instances of the service and the Naming Server would provide those Urls to the parent service. This helps to establish Dynamic relationship between the parent service and the instances of the child services.

We will used Ribbon for client side load balancing that means the parent service will host Ribbon and it would make sure that  the load is evenly distribute among the existing instances that it gets from the name server.

We will used Feign in our service as a mechanism to write simple Restful clients.
The solution for visibility and monitoring  are the ZipKin Distributing Tracing Server 

We will use spring Cloud Sloat to assign ID to request across multiple components and we will use  ZipKin Distributed tracing to trace a request across multiple components 

For logging, security, analytics and things like that we can use the API Gateways(Netflix Zuel API Gateway)

We will also implement Fault Tolerance using Hystrix  if a service is down.
Hystrix helps us configure a default response.

Advantages of MicroService Architecture
1. it enables you to adapt new technology and processes very easily.
2.Dynamic scaling (cloud enabled)
3. Faster release cycle


Spring Cloud Sleuth => it would add an unique ID to a request so that you can place it across multiple components

https://github.com/in28minutes/spring-microservices/tree/master/03.microservices

Centralized Configuration





MicroServicios Architecture
Feign (interface)=> is used to invoke other MicroServices 
1. Feign makes it easy to invoke other MicroServices
2. Feign provides integration with Ribbon which is a client side load balancing framework
3. Feign is one of the components that spring cloud inherits from netflix
4. we create a Feign proxy to talk to the service
@FeignClient(name = "currency-conversion-service", url ="localhost:8000")


API Gateways(Zuul API)
1. authentication, authorization and security
2. Rate Limits
3. Falut tolerance
4. service Agregation
 
http://localhost:8000//currency-exchange/from/USD/to/CAD

http://localhost:8765/currency-exchange-service/currency-exchange/from/USD/to/CAD


http://localhost:8765/currency-conversion-service/currency-converter-feign/from/USD/to/MXN/quantity/999




